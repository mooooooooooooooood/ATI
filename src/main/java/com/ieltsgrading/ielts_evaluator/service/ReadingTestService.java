package com.ieltsgrading.ielts_evaluator.service;

import com.ieltsgrading.ielts_evaluator.dto.ReadingResultDetailDTO;
import com.ieltsgrading.ielts_evaluator.dto.ReadingSubmissionDTO;
import com.ieltsgrading.ielts_evaluator.model.ReadingQuestion;
import com.ieltsgrading.ielts_evaluator.model.ReadingTest;
import com.ieltsgrading.ielts_evaluator.model.ReadingUserAnswer;
import com.ieltsgrading.ielts_evaluator.repository.ReadingQuestionRepository;
import com.ieltsgrading.ielts_evaluator.repository.ReadingTestRepository;
import com.ieltsgrading.ielts_evaluator.repository.ReadingUserAnswerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value; // ⭐ REQUIRED IMPORT
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.servlet.ModelAndView;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;
import com.ieltsgrading.ielts_evaluator.dto.gemini.GeminiRequest; // ⭐ DTO Import (Ensure package is correct)
import com.ieltsgrading.ielts_evaluator.dto.gemini.GeminiResponse; // ⭐ DTO Import (Ensure package is correct)

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpEntity;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;

@Service
public class ReadingTestService {

    //  1. Inject the API Key using @Value from application.properties
    @Value("${gemini.api.key}")
    private String GEMINI_API_KEY;

    // Define the Gemini model URL constants
    private final String GEMINI_MODEL = "gemini-2.5-flash";
    private final String GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1/models/" + GEMINI_MODEL + ":generateContent";


    @Autowired
    private ReadingUserAnswerRepository answerRepository;

    @Autowired
    private ReadingQuestionRepository questionRepository;

    private final RestTemplate restTemplate = new RestTemplate();
    private final String GRADING_API_URL = "http://external-grading-api/grade";
    private final ObjectMapper objectMapper = new ObjectMapper();
    private ReadingTestRepository readingTestRepository;


    // --- Gemini Helper Method ---

    /**
     * Calls the Gemini API to get an explanation for an incorrect answer.
     */
    public String getGeminiExplanation(String questionText, String incorrectAnswer, String correctAnswer) {
        if (this.GEMINI_API_KEY.isEmpty() || this.GEMINI_API_KEY.startsWith("YOUR_")) {
            return "Explanation service is not configured (API key missing).";
        }
        try {
            // ⭐ CRITICAL CHANGE: Added the word count constraint (Max 30 Words) to the prompt ⭐
            String prompt = String.format(
                    "You are an IELTS tutor. Explain why the following answer is incorrect and why the correct answer is right. " +
                            "The explanation MUST be very concise, **maximum 30 words**. " +
                            "Question: \"%s\". My incorrect answer: \"%s\". The correct answer is: \"%s\".",
                    questionText, incorrectAnswer, correctAnswer
            );

            // Prepare the Request Entity (Body and Headers)
            GeminiRequest requestBody = new GeminiRequest(prompt);
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            HttpEntity<GeminiRequest> requestEntity = new HttpEntity<>(requestBody, headers);

            String finalApiUrl = GEMINI_API_BASE_URL + "?key=" + this.GEMINI_API_KEY;

            // Make the API call
            ResponseEntity<GeminiResponse> response = restTemplate.exchange(
                    finalApiUrl,
                    HttpMethod.POST,
                    requestEntity,
                    GeminiResponse.class
            );

            // Parse the response
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return response.getBody().getCandidates().stream()
                        .findFirst()
                        .map(c -> c.getContent().getParts().stream()
                                .findFirst()
                                .map(p -> p.getText())
                                .orElse("No detailed content found."))
                        .orElse("No explanation generated by Gemini.");
            }

            return "API Error: Status " + response.getStatusCode();
        } catch (Exception e) {
            System.err.println("Gemini API call failed: " + e.getMessage());
            return "Explanation unavailable due to connection error.";
        }
    }


    // --- Existing Service Methods ---

    public ReadingTest getTestById(int id) {
        return readingTestRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Reading Test not found with id: " + id));
    }

    @Transactional
    public ModelAndView processAndGradeSubmission(ReadingSubmissionDTO submissionDTO) {

        int testId = submissionDTO.getTestId();
        int userId = 1; // Placeholder: Replace with actual User ID retrieval logic

        // 1. Fetch all questions
        List<ReadingQuestion> allQuestions = questionRepository.findAllByTestId(testId);

        // Convert the list of submitted DTOs to a Map for fast lookup
        Map<Integer, String> userResponsesMap = submissionDTO.getAnswers().stream()
                .collect(Collectors.toMap(
                        ReadingSubmissionDTO.AnswerDTO::getQuestionId,
                        dto -> dto.getUserResponse() != null ? dto.getUserResponse() : ""
                ));

        List<ReadingUserAnswer> answersToStore = new java.util.ArrayList<>();
        // List to hold the DTOs for the result page
        List<ReadingResultDetailDTO> submissionResults = new java.util.ArrayList<>();

        int correctCount = 0;

        // --- CORE SCORING LOGIC (WITHOUT GEMINI CALL) ---
        for (ReadingQuestion question : allQuestions) {
            int questionId = question.getId();

            // ... (Existing JSON parsing logic for question options if needed) ...

            String rawUserResponse = userResponsesMap.getOrDefault(questionId, "");
            String rawCorrectAnswer = question.getCorrectAnswer();

            boolean isCorrect = false;
            // ⭐ Initialize explanation status (default to empty string)
            String explanationStatus = "";

            if (!rawUserResponse.trim().isEmpty()) {
                String normalizedUserResponse = normalizeAnswer(rawUserResponse);
                String normalizedCorrectAnswer = normalizeAnswer(rawCorrectAnswer);
                isCorrect = normalizedUserResponse.equals(normalizedCorrectAnswer);
            }

            if (isCorrect) {
                correctCount++;
            } else if (!rawUserResponse.trim().isEmpty()) {
                // ⭐ CRITICAL CHANGE: Set status to PENDING instead of calling Gemini
                explanationStatus = "PENDING";
            }

            // 3. Create and store the answer entity
            ReadingUserAnswer userAnswer = new ReadingUserAnswer();
            userAnswer.setUserId(userId);
            userAnswer.setQuestion(question);
            userAnswer.setUserResponse(rawUserResponse.trim());
            userAnswer.setIsCorrect(isCorrect);

            answersToStore.add(userAnswer);

            // 4. Map to DTO, passing the PENDING status
            submissionResults.add(new ReadingResultDetailDTO(
                    question.getQuestionOrder(),
                    question.getQuestionText(),
                    userAnswer.getUserResponse(),
                    rawCorrectAnswer,
                    isCorrect,
                    explanationStatus // Pass the PENDING status or empty string
            ));
        }

        // 5. Save all user answers to the database
        answerRepository.saveAll(answersToStore);

        // --- END OF CORE LOGIC (FAST LOADING) ---

        // Set the total questions for the result page
        int totalQuestions = allQuestions.size();

        // Return result view immediately
        ModelAndView mav = new ModelAndView("reading-result");
        mav.addObject("totalQuestions", totalQuestions);
        mav.addObject("score", correctCount);
        mav.addObject("submissionResults", submissionResults); // List with "PENDING" placeholders

        // Get test name safely
        String testName = "Test Results";
        if (!allQuestions.isEmpty()) {
            // Traverse the hierarchy to get test name (assuming relationships are loaded/accessible)
            try {
                testName = allQuestions.get(0).getGroup().getPassage().getTest().getTestName();
            } catch (NullPointerException e) {
                // Fallback if relationships were lazy-loaded or incomplete
                System.err.println("Could not retrieve full test name hierarchy.");
            }
        }
        mav.addObject("testName", testName);

        // Ensure you have the separate fetchSingleExplanation method implemented
        // in this service and the corresponding @PostMapping in the controller.

        return mav;
    }

    private String normalizeAnswer(String answer) {
        if (answer == null) return "";

        // 1. Trim leading/trailing whitespace and brackets
        String normalized = answer.trim();

        // 2. Remove square brackets and trailing commas if any
        normalized = normalized.replaceAll("[\\[\\]]", ""); // remove brackets
        normalized = normalized.replaceAll(",+", "");       // remove commas

        // 3. Convert to lowercase
        normalized = normalized.toLowerCase();

        // 4. Replace multiple spaces/tabs/newlines with a single space
        normalized = normalized.replaceAll("\\s+", " ");

        // 5. Trim again after cleanup
        return normalized.trim();
    }
    public String fetchSingleExplanation(int questionId, String userResponse, String correctAnswer) {
        // 1. You would retrieve the question text here if needed, but since the DTO
        //    already has the necessary context, we can call Gemini directly.

        // 2. Call the Gemini method (which still has the 30-word prompt logic):
        ReadingQuestion question = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("Question not found"));

        String explanation = getGeminiExplanation(
                question.getQuestionText(),
                userResponse,
                correctAnswer
        );

        return explanation;
    }
}